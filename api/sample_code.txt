
#sample 1
func (s *Server) Login(w http.ResponseWriter, r *http.Request) {
	
	//dosomething()

	if r.Method != "GET" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	
	ref, err := auth.ExtractTokenReferenceSecret(r)
		log.Println("[ref FROM Login.GO]", ref)
		if err != nil {
			responses.ERROR(w, http.StatusUnauthorized, errors.New("Unauthorized"))
			return
	  }

	  //do encrpytion of os.Getenv("ACCESS_SECRET")
	  var  osv = []byte(os.Getenv("ACCESS_SECRET"))
	  res := bytes.Compare(ref, osv)

	  log.Println("res", ref)
	  log.Println("REF FROM ENV not-byte", osv)

	  if res == 0 {
		var resMsg = "ok"
		log.Println("msg shld be ok",resMsg)

		//websocket here
		c, err := Upgrader.Upgrade(w, r, nil)
				if err != nil {
					m := "Unable to upgrade to websockets"
					log.Println(m)
					http.Error(w, m, http.StatusBadRequest)
					return
				}

				if c != nil{
					m := "Client successfully connected..."
					log.Println("connected msg",m)
				}

			defer c.Close()

			for{
			mt, data, err := c.ReadMessage()
			log.Println("data read", data)
			log.Println("mt read", mt)
			if err != nil {
				if websocket.IsCloseError(err, websocket.CloseGoingAway) || err == io.EOF {
					log.Println("Websocket closed!")
					break
				}
				log.Print("Error reading websocket message")
			}
				
			err = c.WriteJSON(data)
			if err != nil {
				log.Println("writeERROR:", err)
				break
			}		
			fmt.Print("m writer", data)	
			
			
			}
		
	  }else{
		log.Println("ERROR")
		return
	}

}


//SignIn func to be claaed in Login func
func (s *Server) SignInWebApp(email string) (string, error) {

	var err error

	user := models.User{}

	//check for token in redis
	err = s.DB.Debug().Model(models.User{}).Where("email = ?", email).Take(&user).Error
	if err != nil {
		return "", err
	}
	
	return auth.CreateToken(user.ID)
}


###sample 2 http post with websocket # broadcast to all sockets

type PassportTokenStruct struct {
	Token string `json:"token"`
	CreatedAt time.Time `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
}

var clients = make(map[*websocket.Conn]bool)
var broadcast = make(chan *PassportTokenStruct)
var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

func writer(token *PassportTokenStruct) {

	broadcast <- token
}

func (s *Server) Login(w http.ResponseWriter, r *http.Request) {

	var pass PassportTokenStruct
	
	
	if err := json.NewDecoder(r.Body).Decode(&pass); err != nil {
		if websocket.IsCloseError(err, websocket.CloseGoingAway) || err == io.EOF {
			log.Println("Websocket closed!")
			return
		}

	}

	defer r.Body.Close()
	go writer(&pass)
	 
}



func wsHandlerMobileLogin(w http.ResponseWriter, r *http.Request) {

	//ws == c
	c, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		m := "Unable to upgrade to websockets"
		log.Println(m)
		http.Error(w, m, http.StatusBadRequest)
		return
	}

	if c != nil {
		m := "Client successfully connected..."
		log.Println("connected msg", m)
	}

	clients[c] = true
}


func Echo() {
	log.Println("ok")
	for {
		val := <-broadcast
		token := fmt.Sprintf(val.CreatedAt.Format("01-02-2006 15:04:05"))
		// dt := time.Now()
		//dtt := fmt.Println(dt.Format("01-02-2006 15:04:05"))
		//arrProp = BitConverter.GetBytes(dt.Ticks)
		for client := range clients {
			err := client.WriteMessage(websocket.TextMessage, []byte(token))
			if err != nil {
				log.Println("ERROR FROM ECHO", err)
				client.Close()
				delete(clients, client)
			}
		}

	}

}
*************************************************************

type PassportTokenStruct struct {
	Token string `json:"token"`
	CreatedAt time.Time `gorm:"default:CURRENT_TIMESTAMP" json:"created_at"`
}

var client = make(map[*websocket.Conn]bool)
var broadcast = make(chan *PassportTokenStruct)
var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

func writer(token *PassportTokenStruct) {
	broadcast <- token
}


func (s *Server) Login(w http.ResponseWriter, r *http.Request) {

	var pass PassportTokenStruct
	
	
	if err := json.NewDecoder(r.Body).Decode(&pass); err != nil {
		if websocket.IsCloseError(err, websocket.CloseGoingAway) || err == io.EOF {
			log.Println("Websocket closed!")
			return
		}

	}

	//decrypt token here 

	defer r.Body.Close()
	go writer(&pass)
	 
}



func wsHandlerMobileLogin(w http.ResponseWriter, r *http.Request) {

	//ws == c
	c, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		m := "Unable to upgrade to websockets"
		log.Println(m)
		http.Error(w, m, http.StatusBadRequest)
		return
	}

	if c != nil {
		m := "Client successfully connected..."
		log.Println("connected msg", m)
	}

	client[c] = true
}


func Echo() {
	log.Println("ok")
	for {
		val := <-broadcast
		token := fmt.Sprintf(val.Token, val.CreatedAt.Format(time.RFC850))
		//token := fmt.Sprintf(val.CreatedAt.Format("01-02-2006 15:04:05"))
		for client := range client {
			err := client.WriteMessage(websocket.TextMessage, []byte(token))
			if err != nil {
				log.Println("ERROR FROM ECHO", err)
				client.Close()
				//delete(client)
			}
		}

	}

}


func (s *Server)CreateDB(DbUser, DbPassword, DbPort, DbHost,DbName string) {

	var err error

	DBURL := fmt.Sprintf("host=%s port=%s user=%s dbname=%s sslmode=disable password=%s", DbHost, DbPort, DbUser, DbName, DbPassword)
	s.DB, err = gorm.Open("postgres", DBURL)
	if err != nil {
		fmt.Printf("Cannot connect to %s database",err)
		//log.Fatal("This is the error:", err)
	} else {
			err := s.DB.Exec("CREATE DATABASE "+ DbName)
				if err != nil {
					log.Println("Cannot create  database",err)
					//log.Fatal("This is the error:", err)
				} else {
					fmt.Println("Db created ", DbName)
				}
	
			err = s.DB.Exec("USE "+ DbName)
			if err != nil {
				panic(err)
			}else{
				fmt.Println("We are connected to the database", DbName)
				
				defer s.DB.Close()
			}
		    
	}
	
//	_,err = db.Exec("CREATE TABLE example ( id integer, data varchar(32) )")
//	if err != nil {
//		panic(err)
//	}

 }



#################################################################################

//func ValidateLoginToken(tokenData []byte)(TokenData, error){
//	 var tokenMsg TokenData
//	 var tokenMsgLen = 32
//		var err = "Token appears to be invalide"
//	 if  len(tokenData) != tokenMsgLen{
//		panic(err)
		//return
//	 }
//	
//	return tokenMsg, nil
//}

//DoEvery auto call createToken func every second
func DoEvery(d time.Duration, f func(time.Time)){

	for x := range time.Tick(d){
		f(x)
	}
}



func HelloWorld(t time.Time){
	fmt.Println("%v: Hello world\n ",t)
}



func dosomething( s string){
	fmt.Println("doing something 2" , s)
}


func StartPolling2(){
	for{

		<-time.After(2*time.Second)
		go dosomething("polling from 2")
	}
}
